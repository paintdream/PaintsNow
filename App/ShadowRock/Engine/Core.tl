--[====================================================================[
								<Core.lua>
					A pure Lua utility tool for Lua 5.3
							By PaintDream (paintdream@paintdream.com)
							Version: 2016.12.21
--]====================================================================]

--[====================================================================[
								<Document>
Usage:
	DEBUG = true -- or false if debug is disabled.
	local Core = require("Engine/Core")

<Debug Functions>
	[function Core.Hook(object, readHandler(object, key, value),
		writeHandler(object, key, oldvalue, newvalue))]
		Create a level of hook on object. Overrides all read or write
			operations.
	[function Core.UnHook(object)]
		Remove a level of hook on object.

	Exsample:
		local a = { test = { 'haha', b = 'str' }, c = 23 }
		Hook(a, function (object, key, value)
			print("TRYING TO READ " .. key .. " = " .. value)
			return value + 1
		end, function (object, key, oldValue, newValue)
			print("TRYING TO WRITE " .. key .. " = " .. newValue)
			return oldValue -- readonly
		end)

		print("PRINT VALUE" .. a.c)
		a.c = 2
		print("PRINT VALUE" .. a.c)
		UnHook(a)
		a.c = 2
		print("PRINT VALUE" .. a.c)


<Encode/Decode Functions>
	[function Dump(t)]
		Returns a lua string representation of t.

	[function Load(t)]
		Loads a lua string generated by Dump() and rebuild the table.
		Remarks: Dump/Load supports circled reference in table.

	[function Encode(t, dictionary)]
		Encode a lua table and returns a binary representation of it.

	[function Decode(t, dictionary)]
		Decode a lua table from a binary representation by Encode.
		Remarks: The data will be compressed if there are duplicated
			strings/tables in t.
		Remarks: The parameter dictionary can be omitted or reused for
			frequency data exchange to reduce data length.
		Exsample:
			-- sender --
			dict = {}
			a = Encode(aaa, dict)
			send(a)
			b = Encode(bbb, dict)

			-- receiver --
			dict = {}
			aaa = Decode(a, dict)
			bbb = Decode(b, dict)

			Notice that you must keep the same order of Encode(s)
				and Decode(s) between sender and receiver if parameter
				dict is enabled. Otherwise you must set dict to nil.
				For example:

			-- sender --
			a = Encode(aaa)
			b = Encode(bbb)

			-- receiver --
			-- misorder
			bbb = Decode(b)
			aaa = Decode(a)
		Long exsample:
			local inner = { 'def' }
			local ms = { 'abc' }
			local mc = { 'abc' }
			local md = { 'abc' }
			local test = { 'a', ['bbb'] = 23, 'fff', 89, ['def'] = 'bbb', ['ccc'] = inner, ['ms'] = ms, ['md'] = md, ['mm'] = mc }
			inner.rec = test
			local data = Encode(test)
			local org = Decode(data)

			local mark = { }
			local function Output(org)
				mark[org] = true
				for k, v in pairs(org) do
					print("[" .. k .. "] = ")
					if type(v) == "table" then
						print("{ ")
						if mark[v] == nil then
							mark[v] = true
							Output(v)
						else
							print("DUP")
						end
						print("} ")
					else
						print("" .. v)
					end
				end
			end

			Output(org)

			local large = {}
			for i = 0, 1000 do
				table.insert(large, { text = 'hello, world', 123478, 9234, 'ase' })
			end

			print("ENCODE LENGTH: " .. string.len(Encode(large)))


--]====================================================================]

local Core = record end

function Core.Merge(g : { any : any }, t : { any : any }) : { any : any }
	for k, v in pairs(t) do
		if type(v) == "table" then
			local w = g[k] or {}
			assert(type(w) == "table")
			g[k] = Core.Merge(w as { any : any }, v as { any : any }) as any
		else
			g[k] = v
		end
	end

	return g
end

function Core.Diff(g : { any : any }, t : { any : any }) : { any : any }
	for k, v in pairs(t) do
		if type(t[k]) == "table" and type(v) == "table" then
			local w = g[k] or {}
			assert(type(w) == "table")
			g[k] = Core.Diff(w as { any : any }, v as { any : any })
		else
			g[k] = nil
		end
	end

	return g
end

function Core.Patch(g : { any : any }, t : { any : any }) : { any : any }
	-- clear metatable first
	setmetatable(g, nil as METATABLE)
	-- clear old values ...
	for k, v in pairs(g) do
		g[k] = nil
	end

	-- copy new values ...
	for k, v in pairs(t) do
		g[k] = v
	end

	setmetatable(g, getmetatable(t))

	return g
end

function Core.UnHook(object : { any : any }) : { any : any }
	local mt = getmetatable(object) as { any : any }
	assert(mt)

	local org = getmetatable(mt)
	setmetatable(object, org)

	-- Export vars
	for k, v in pairs(mt.__Holder as { any : any }) do
		object[k] = v
	end

	return object
end

function Core.Hook(object : { any : any }, readHandler : function ({ any: any}, any, any) : (any), writeHandler : function ({ any: any}, any, any, any) : (any))
	local org = getmetatable(object) as { any : any }
	local holder : { any : any } = {}
	local mt : { string : any } = {}
	mt.__Holder = holder

	if readHandler then
		mt.__index = function (o : { any : any }, k : any) : any
			assert(o == object)
			return readHandler(object, k, (mt.__Holder as { any : any })[k])
		end
	end

	if writeHandler then
		mt.__newindex = function (o : { any : any }, k : any, v : any)
			assert(o == object)
			if writeHandler then
				(mt.__Holder as { any : any })[k] = writeHandler(object, k, (mt.__Holder as { any : any })[k], v)
			else
				(mt.__Holder as { any : any })[k] = v
			end
		end
	end

	-- Import vars
	for k, v in pairs(object) do
		(mt.__Holder as { any : any })[k] = v
		object[k] = nil
	end

	setmetatable(mt, org as METATABLE)
	setmetatable(object, mt as METATABLE)
end

local function SafeStr(v : string) : string
	return (string.gsub(v, "'", "\\'"))
end

local function ToStr(v : any) : string
	local t = type(v)
	if t == "number" then
		return "" .. tostring(v)
	elseif t == "boolean" then
		return v and "true" or "false"
	elseif t == "string" then
		return "'" .. SafeStr(v as string) .. "'"
	end

	error("Error type " .. t)
	return "Invalid"
end

local function Safepairs(tab : { any : any }) : function () : (any, any)
	local compare : { any } = { }
	for k in pairs(tab) do
		table.insert(compare, k)
	end

	table.sort(compare, function(a : any, b : any) : boolean
		local ta = type(a)
		local tb = type(b)
		return ta == tb and (a as number) < (b as number) or (ta as string) < (tb as string)
	end)
	local i = 0

	return function () : (any, any)
		i = i + 1
		local k = compare[i]
		local v = tab[k]
		return k, v
	end
end

function Core.Dump(obj, binary) : string
	local record : { any : any } = { }
	local str : { string } = {}

	table.insert(str, "return \n")

	local current = 1
	local function DumpEx(data : any | { any : any })
		local t = type(data)
		if t == "table" then
			local node = data as { any : any }
			table.insert(str, "{\n")

			if record[node] then
				table.insert(str, "__ref = " .. tostring(record[node]))
			else
				record[node] = current
				current = current + 1
				for k, v in Safepairs(node) do
					-- table as key is not allowed
					assert(type(k) == "boolean" or type(k) == "number" or type(k) == "string")
					table.insert(str, "[" .. ToStr(k) .. "] = ")
					DumpEx(v)
					table.insert(str, ", \n")
				end

				-- node.__base = nil -- clear
			end

			table.insert(str, "}")
		else
			local t = ToStr(data)
			if t then
				table.insert(str, t)
			end
		end
	end

	DumpEx(obj)

	if binary then
		local func : function (any) : any = load(table.concat(str))
		return string.dump(func, true)
	else
		return str[1]
	end
end


local maskValueTable = 1 -- 1 << 0
local maskValueRef = 2 -- 1 << 1
local maskKeyTable = 4 -- 1 << 2
local maskKeyRef = 8 -- 1 << 3
local maskBoolAsNumber = 16 -- 1 << 4

local function EncodeEx(object : { any : any }, formatDict : { any : any }, refDict : { any : any }) : string
	refDict = refDict or {}
	local ret : { any } = {}
	local format : { string } = {}
	table.insert(format, "!1<")

	local function AddDictEntry(object : any)
		refDict.__counter = (refDict.__counter as number or 0) + 1
		refDict[object] = refDict.__counter
	end

	AddDictEntry(object as any)

	local function WriteMask(typeMask : number, value : any, ref : number, tab : number) : (number, string, any)
		local typeValue = type(value)
		local cache = refDict[value]
		local retTypeMask : number = typeMask
		local retType : string = "I4"
		local retValue : any = ""

		if cache then
			retTypeMask = typeMask | ref
			retType = "I4"
			retValue = cache
		elseif typeValue == "table" then
			local s = EncodeEx(value as { any : any }, formatDict, refDict)
			cache = refDict[s]
			if cache then
				retTypeMask = typeMask | tab | ref
				retType = "I4"
				retValue = cache
			else
				AddDictEntry(s)
				retTypeMask = typeMask | tab
				retType = "s"
				retValue = s
			end
		elseif typeValue == "string" then
			AddDictEntry(value)
			retTypeMask = typeMask
			retType = "s"
			retValue = value
		elseif typeValue == "boolean" then
			retTypeMask = typeMask | maskBoolAsNumber
			retType = "I4"
			retValue = (value and 1 or 0)
		else
			assert(typeValue == "number", typeValue)
			retTypeMask = typeMask
			retType = "n"
			retValue = value
		end

		return retTypeMask, retType, retValue
	end

	for k, v in pairs(object) do
		table.insert(format, "b")
		local typeMask = 0
		local kt : string
		local kc : any
		local vt : string
		local vc : any

		typeMask, kt, kc = WriteMask(typeMask, k, maskKeyRef, maskKeyTable)
		typeMask, vt, vc = WriteMask(typeMask, v, maskValueRef, maskValueTable)

		table.insert(ret, typeMask)
		table.insert(format, kt)
		table.insert(ret, kc)
		table.insert(format, vt)
		table.insert(ret, vc)
	end

	local s = table.concat(format)
	local f = formatDict[s]
	if not f then
		formatDict.__counter = (formatDict.__counter as number or 0) + 1
		formatDict[s] = formatDict.__counter
		f = formatDict.__counter
	end

	local content = string.pack(s, table.unpack(ret))
	return string.pack("!1<I4s", f, content)
end

function Core.Encode(object : { any : any }, refDict : { any : any }) : string
	local formatDict : { string : any } = {}
	local data = EncodeEx(object, formatDict, refDict)
	local title : string = "!1<" .. string.rep("s", formatDict.__counter as number or 0)
	local formatTable : { any } = {}

	for i = 1, formatDict.__counter as number or 0 do
		formatTable[i] = false
	end

	for k, v in pairs(formatDict) do
		if k ~= "__counter" then
			formatTable[v as number] = k
		end
	end
	
	local format = string.pack(title, table.unpack(formatTable))
	return string.pack("!1<sss", title, format, data)
end

local function DecodeEx(data : string, formatDict : { any : any }, refDict : { any }) : ({ any : any }, string)
	refDict = refDict or {}
	local s, content, unread = string.unpack("!1<I4s", data)
	local expand = table.pack(string.unpack(formatDict[s] as string, content as string)) as { any }
	local object : { any : any } = {}

	table.insert(refDict, object)

	local function WriteContent(object : any, typeMask : number, ref : number, tab : number) : any
		if (typeMask & ref) == ref then
			assert(type(object) == "number")
			local ret : any = refDict[object as number]
			if (typeMask & tab) == tab then
				ret = DecodeEx(ret as string, formatDict, refDict)				
			end
			return ret
		elseif (typeMask & tab) == tab then
			assert(type(object) == "string")
			local ret = DecodeEx(object as string, formatDict, refDict)
			table.insert(refDict, object)
			return ret
		else
			if type(object) == "string" then
				table.insert(refDict, object)
			end

			return object
		end
	end

	for i = 1, #expand - 3, 3 do
		local typeMask = expand[i] as number
		local key = WriteContent(expand[i + 1], typeMask, maskKeyRef, maskKeyTable)
		local value = WriteContent(expand[i + 2], typeMask, maskValueRef, maskValueTable)
		
		if (typeMask & maskBoolAsNumber) == maskBoolAsNumber then
			value = (value ~= 0)
		end

		-- key of type number must be number
		object[key] = value
	end

	return object, unread as string
end

function Core.Decode(data : string, refDict : { any }) : ({ any : any }, string)
	local title, format, text = string.unpack("!1<sss", data)
	local formatTable = table.pack(string.unpack(title as string, format as string))

	return DecodeEx(text as string, formatTable as { any : any }, refDict)
end

global Event = record
	Co : thread
	Waiting : boolean
	Finished : boolean
	Returns : { any }
end

function Core.Event() : Event
	return { Co = coroutine.running(), Waiting = false, Finished = false, Returns = {} }
end

function Core.Reset(event : Event) : Event
	event.Waiting = false
	event.Finished = false
	event.Returns = {}
	return event
end

function Core.Signal(event : Event, ... : any)
	if event.Waiting then
		coroutine.resume(event.Co, ...)
	else
		event.Finished = true
		event.Returns = table.pack(...) as { any }
	end
end

function Core.Wait(event : Event) : any...
	if event.Finished then
		return table.unpack(event.Returns)
	else
		event.Waiting = true
		return coroutine.yield()
	end
end

function Core.RandomLucky(t : number, alpha : number, eps : number, initthres : number) : (function () : (boolean, number), number)
	assert(t < 0.5)
	assert(alpha >= 0 and alpha <= 1)

	local s = 2.0 * t / (1.0 - 2.0 * t)
	alpha = 1.0 - (1.0 - ((1 - t) ^ s) * (t ^ (s * t / (1 - t)))) * t * alpha

	eps = eps or 1e-12

	local e = 1.0 / t
	local accurate = eps * e

	-- numeric method
	local min = 0.0
	local max = 1.0
	local p = t

	-- print("BEGIN")
	while max - min > eps do
		local q = 1.0
		local a1 = 1.0
		local a2 = 1.0
		local sum = 0.0
		local item = 0.0
		local qq = 1.0 - p

		for i = 1, 16 * e do
			assert(a1 <= 1)
			item = q * i * a2 * (1.0 - qq * a1)
			a2 = a2 * a1
			a1 = a1 * alpha
			sum = sum + item
			q = q * (1.0 - p)

			if sum > e + accurate or item < accurate then
				break
			end
		end

		-- print("SUM = ", sum)

		local diff = sum - e
		if math.abs(diff) < accurate then
			break
		elseif diff > 0 then
			min = p
		else
			max = p
		end
		
		p = (min + max) / 2
	end

	-- print("FINAL TEST p = ", p)
	-- then we get p

	local threshold = initthres or p
	return function () : (boolean, number)
		if math.random() <= threshold then
			threshold = p 
			return true, threshold
		else
			-- print("THRES = ", threshold)
			threshold = 1.0 - (1.0 - threshold) * alpha
			return false, threshold
		end
	end, p
end

--[[
math.randomseed(os.time())

local args = { ... }

local p = tonumber(args[1]) or 0.05
local last = tonumber(args[2]) or 16
for k = 1, last do
	local sum = 0
	local count = 100000
	local generator, p0 = RandomLucky(p, 0.5 ^ (k - 1))
	for i = 1, count do
		for j = 1, 100000000 do
			if generator( then
				sum = sum + j
				break
			end
		end
	end

	print(string.format("K = %d E = %6.3f E0 = %6.3f |E - E0| = %6.3f p0 = %6.12f p = %6.3f", k, 1.0 / p, sum / count, 1.0 / p - sum / count, p0, p))
end

]]
return Core
